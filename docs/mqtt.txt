-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An MQTT protocol implementation (client and server).
--   
--   This project aims to supply a rock-solid MQTT implementation suitable
--   for production use.
@package mqtt
@version 0.1.0.0


module Network.MQTT.Client


module Network.MQTT.Topic

-- | According to the MQTT specification a topic
--   
--   <ul>
--   <li>may not be empty</li>
--   <li>may not contain <tt>+</tt>, <tt>#</tt> or <tt>\NUL</tt>
--   characters</li>
--   </ul>
data Topic
topicLevels :: Topic -> NonEmpty Level
topicLength :: Topic -> Int
topicParser :: Parser Topic
topicBuilder :: Topic -> Builder
data Filter
filterLevels :: Filter -> NonEmpty Level
filterLength :: Filter -> Int
filterParser :: Parser Filter
filterBuilder :: Filter -> Builder
data Level
levelParser :: Parser Level
multiLevelWildcard :: Level
singleLevelWildcard :: Level
startsWithDollar :: Level -> Bool
instance GHC.Classes.Ord Network.MQTT.Topic.Topic
instance GHC.Classes.Eq Network.MQTT.Topic.Topic
instance GHC.Classes.Ord Network.MQTT.Topic.Filter
instance GHC.Classes.Eq Network.MQTT.Topic.Filter
instance GHC.Classes.Ord Network.MQTT.Topic.Level
instance GHC.Classes.Eq Network.MQTT.Topic.Level
instance GHC.Show.Show Network.MQTT.Topic.Topic
instance GHC.Show.Show Network.MQTT.Topic.Filter
instance GHC.Show.Show Network.MQTT.Topic.Level
instance Data.String.IsString Network.MQTT.Topic.Topic
instance Data.String.IsString Network.MQTT.Topic.Filter
instance Data.String.IsString Network.MQTT.Topic.Level


module Network.MQTT.RoutingTree

-- | The <a>RoutingTree</a> is a map-like data structure designed to hold
--   elements that can efficiently be queried according to the matching
--   rules specified by MQTT. The primary purpose is to manage client
--   subscriptions, but it can just as well be used to manage permissions
--   etc.
--   
--   The tree consists of nodes that may or may not contain values. The
--   edges are filter components. As some value types have the concept of a
--   null (i.e. an empty set) the <a>RoutingTreeValue</a> is a class
--   defining the data family <a>RoutingTreeNode</a>. This is a performance
--   and size optimization to avoid unnecessary boxing and case
--   distinction.
newtype RoutingTree a
RoutingTree :: Map Level (RoutingTreeNode a) -> RoutingTree a
[branches] :: RoutingTree a -> Map Level (RoutingTreeNode a)
class RoutingTreeValue a where data RoutingTreeNode a where {
    data family RoutingTreeNode a;
}
node :: RoutingTreeValue a => RoutingTree a -> Maybe a -> RoutingTreeNode a
nodeNull :: RoutingTreeValue a => a -> Bool
nodeTree :: RoutingTreeValue a => RoutingTreeNode a -> RoutingTree a
nodeValue :: RoutingTreeValue a => RoutingTreeNode a -> Maybe a
nodeFromTree :: RoutingTreeValue a => RoutingTree a -> RoutingTreeNode a
nodeFromTreeAndValue :: RoutingTreeValue a => RoutingTree a -> a -> RoutingTreeNode a
null :: RoutingTree a -> Bool
empty :: RoutingTree a
size :: RoutingTreeValue a => RoutingTree a -> Int
singleton :: RoutingTreeValue a => Filter -> a -> RoutingTree a

-- | Match a <a>Topic</a> against a <a>RoutingTree</a>.
--   
--   The function returns true iff the tree contains at least one node that
--   matches the topic <i>and</i> contains a value (including nodes that
--   are indirectly matched by wildcard characters like <a>+</a> and
--   <tt>#</tt> as described in the MQTT specification).
matchTopic :: RoutingTreeValue a => Topic -> RoutingTree a -> Bool

-- | Match a <a>Filter</a> against a <a>RoutingTree</a>.
--   
--   The function returns true iff the tree contains a path that is <i>less
--   or equally specific</i> than the filter and the terminal node contains
--   a value that is not <a>nodeNull</a>.
--   
--   <pre>
--   match (singleton "#") "a"     = True
--   match (singleton "#") "+"     = True
--   match (singleton "#") "a/+/b" = True
--   match (singleton "#") "a/+/#" = True
--   match (singleton "+") "a"     = True
--   match (singleton "+") "+"     = True
--   match (singleton "+") "+/a"   = False
--   match (singleton "+") "#"     = False
--   match (singleton "a") "a"     = True
--   match (singleton "a") "b"     = False
--   match (singleton "a") "+"     = False
--   match (singleton "a") "#"     = False
--   </pre>
matchFilter :: RoutingTreeValue a => Filter -> RoutingTree a -> Bool

-- | Collect all values of nodes that match a given topic (according to the
--   matching rules specified by the MQTT protocol).
lookup :: (RoutingTreeValue a, Monoid a) => Topic -> RoutingTree a -> a
insert :: RoutingTreeValue a => Filter -> a -> RoutingTree a -> RoutingTree a
insertWith :: RoutingTreeValue a => (a -> a -> a) -> Filter -> a -> RoutingTree a -> RoutingTree a
insertFoldable :: (RoutingTreeValue a, Foldable t) => t (Filter, a) -> RoutingTree a -> RoutingTree a
map :: (RoutingTreeValue a, RoutingTreeValue b) => (a -> b) -> RoutingTree a -> RoutingTree b
mapMaybe :: (RoutingTreeValue a, RoutingTreeValue b) => (a -> Maybe b) -> RoutingTree a -> RoutingTree b
adjust :: RoutingTreeValue a => (a -> a) -> Filter -> RoutingTree a -> RoutingTree a
delete :: RoutingTreeValue a => Filter -> RoutingTree a -> RoutingTree a
union :: (RoutingTreeValue a, Monoid a) => RoutingTree a -> RoutingTree a -> RoutingTree a
unionWith :: (RoutingTreeValue a) => (a -> a -> a) -> RoutingTree a -> RoutingTree a -> RoutingTree a
differenceWith :: (RoutingTreeValue a, RoutingTreeValue b) => (a -> b -> Maybe a) -> RoutingTree a -> RoutingTree b -> RoutingTree a
instance (Network.MQTT.RoutingTree.RoutingTreeValue a, GHC.Base.Monoid a) => GHC.Base.Monoid (Network.MQTT.RoutingTree.RoutingTree a)
instance (Network.MQTT.RoutingTree.RoutingTreeValue a, GHC.Classes.Eq a) => GHC.Classes.Eq (Network.MQTT.RoutingTree.RoutingTree a)
instance (Network.MQTT.RoutingTree.RoutingTreeValue a, GHC.Show.Show a) => GHC.Show.Show (Network.MQTT.RoutingTree.RoutingTree a)
instance Network.MQTT.RoutingTree.RoutingTreeValue Data.IntSet.Base.IntSet
instance Network.MQTT.RoutingTree.RoutingTreeValue (Data.Functor.Identity.Identity a)
instance Network.MQTT.RoutingTree.RoutingTreeValue ()
instance Network.MQTT.RoutingTree.RoutingTreeValue GHC.Types.Bool


module Network.MQTT.Message
type ClientIdentifier = Text
type SessionPresent = Bool
type CleanSession = Bool
type Retain = Bool
type KeepAliveInterval = Word16
type Username = Text
newtype Password
Password :: ByteString -> Password
type PacketIdentifier = Int
data QualityOfService
Qos0 :: QualityOfService
Qos1 :: QualityOfService
Qos2 :: QualityOfService
data ConnectionRejectReason
UnacceptableProtocolVersion :: ConnectionRejectReason
IdentifierRejected :: ConnectionRejectReason
ServerUnavailable :: ConnectionRejectReason
BadUsernameOrPassword :: ConnectionRejectReason
NotAuthorized :: ConnectionRejectReason
data Message
Message :: !Topic -> !ByteString -> !QualityOfService -> !Retain -> !Duplicate -> Message
[msgTopic] :: Message -> !Topic
[msgBody] :: Message -> !ByteString
[msgQos] :: Message -> !QualityOfService
[msgRetain] :: Message -> !Retain
[msgDuplicate] :: Message -> !Duplicate
data ClientMessage
ClientConnect :: !ClientIdentifier -> !CleanSession -> !KeepAliveInterval -> !(Maybe Message) -> !(Maybe (Username, Maybe Password)) -> ClientMessage
[connectClientIdentifier] :: ClientMessage -> !ClientIdentifier
[connectCleanSession] :: ClientMessage -> !CleanSession
[connectKeepAlive] :: ClientMessage -> !KeepAliveInterval
[connectWill] :: ClientMessage -> !(Maybe Message)
[connectCredentials] :: ClientMessage -> !(Maybe (Username, Maybe Password))
ClientPublish :: {-# UNPACK #-} !PacketIdentifier -> !Message -> ClientMessage
ClientPublishAcknowledged :: {-# UNPACK #-} !PacketIdentifier -> ClientMessage
ClientPublishReceived :: {-# UNPACK #-} !PacketIdentifier -> ClientMessage
ClientPublishRelease :: {-# UNPACK #-} !PacketIdentifier -> ClientMessage
ClientPublishComplete :: {-# UNPACK #-} !PacketIdentifier -> ClientMessage
ClientSubscribe :: {-# UNPACK #-} !PacketIdentifier -> ![(Filter, QualityOfService)] -> ClientMessage
ClientUnsubscribe :: {-# UNPACK #-} !PacketIdentifier -> ![Filter] -> ClientMessage
ClientPingRequest :: ClientMessage
ClientDisconnect :: ClientMessage
clientMessageBuilder :: ClientMessage -> Builder
clientMessageParser :: Get ClientMessage
data ServerMessage
ServerConnectionAccepted :: !SessionPresent -> ServerMessage
ServerConnectionRejected :: !ConnectionRejectReason -> ServerMessage
ServerPublish :: {-# UNPACK #-} !PacketIdentifier -> !Message -> ServerMessage
ServerPublishAcknowledged :: {-# UNPACK #-} !PacketIdentifier -> ServerMessage
ServerPublishReceived :: {-# UNPACK #-} !PacketIdentifier -> ServerMessage
ServerPublishRelease :: {-# UNPACK #-} !PacketIdentifier -> ServerMessage
ServerPublishComplete :: {-# UNPACK #-} !PacketIdentifier -> ServerMessage
ServerSubscribeAcknowledged :: {-# UNPACK #-} !PacketIdentifier -> ![Maybe QualityOfService] -> ServerMessage
ServerUnsubscribeAcknowledged :: {-# UNPACK #-} !PacketIdentifier -> ServerMessage
ServerPingResponse :: ServerMessage
serverMessageBuilder :: ServerMessage -> Builder
serverMessageParser :: Get ServerMessage
lengthParser :: Get Int
lengthBuilder :: Int -> Builder
utf8Parser :: Get Text
utf8Builder :: Text -> (Builder, Int)
instance GHC.Show.Show Network.MQTT.Message.ServerMessage
instance GHC.Classes.Eq Network.MQTT.Message.ServerMessage
instance GHC.Show.Show Network.MQTT.Message.ClientMessage
instance GHC.Classes.Eq Network.MQTT.Message.ClientMessage
instance GHC.Show.Show Network.MQTT.Message.Message
instance GHC.Classes.Ord Network.MQTT.Message.Message
instance GHC.Classes.Eq Network.MQTT.Message.Message
instance GHC.Enum.Bounded Network.MQTT.Message.ConnectionRejectReason
instance GHC.Enum.Enum Network.MQTT.Message.ConnectionRejectReason
instance GHC.Show.Show Network.MQTT.Message.ConnectionRejectReason
instance GHC.Classes.Ord Network.MQTT.Message.ConnectionRejectReason
instance GHC.Classes.Eq Network.MQTT.Message.ConnectionRejectReason
instance GHC.Show.Show Network.MQTT.Message.QualityOfService
instance GHC.Classes.Ord Network.MQTT.Message.QualityOfService
instance GHC.Classes.Eq Network.MQTT.Message.QualityOfService
instance GHC.Classes.Eq Network.MQTT.Message.Password
instance GHC.Show.Show Network.MQTT.Message.Password

module Network.MQTT.RetainedMessages
newtype RetainedTree
RetainedTree :: (Map Level RetainedNode) -> RetainedTree
data RetainedNode
RetainedNode :: RetainedTree -> (Maybe Message) -> RetainedNode
empty :: RetainedTree
singleton :: Message -> RetainedTree
insert :: Message -> RetainedTree -> RetainedTree
lookupFilter :: Filter -> RetainedTree -> Set Message


module Network.MQTT.Authentication

-- | A peer identity optionally associated with connection/session specific
--   information. newtype Principal = Principal T.Text deriving (Eq, Ord,
--   Show)
--   
--   An <a>Authenticator</a> is able to determine a <a>Principal</a>'s
--   identity from a <tt>Request</tt>.
class (Exception (AuthenticationException a), Eq (Principal a), Ord (Principal a), Show (Principal a)) => Authenticator a where data Principal a data AuthenticatorConfig a data AuthenticationException a where {
    data family Principal a;
    data family AuthenticatorConfig a;
    data family AuthenticationException a;
}

-- | Try to determine a <a>Principal</a>'s identity from connection
--   <tt>Request</tt>.
--   
--   The operation shall return <a>Nothing</a> in case the authentication
--   mechanism is working, but couldn't associate an identity. It shall
--   throw and <a>AuthenticationException</a> in case of other problems.
newAuthenticator :: Authenticator a => AuthenticatorConfig a -> IO a
authenticate :: Authenticator a => a -> ConnectionRequest -> IO (Maybe (Principal a))
hasPublishPermission :: Authenticator a => a -> Principal a -> Topic -> IO Bool
hasSubscribePermission :: Authenticator a => a -> Principal a -> Filter -> IO Bool

-- | This class defines how the information gathered from a connection
--   request looks like. An <a>Authenticator</a> may use whatever
--   information it finds suitable to authenticate the <a>Principal</a>.
data ConnectionRequest
ConnectionRequest :: Text -> Bool -> Bool -> Maybe (Username, Maybe Password) -> Maybe (ByteString, [(CI ByteString, ByteString)]) -> Maybe CertificateChain -> Maybe ByteString -> ConnectionRequest
[requestClientIdentifier] :: ConnectionRequest -> Text
[requestCleanSession] :: ConnectionRequest -> Bool

-- | Is this connection secure in terms of <a>Transport Layer Security</a>?
[requestSecure] :: ConnectionRequest -> Bool

-- | The username and password supplied with the MQTT handshake.
[requestCredentials] :: ConnectionRequest -> Maybe (Username, Maybe Password)

-- | The HTTP request head in case the client connected via
--   <a>WebSocket</a>.
[requestHttp] :: ConnectionRequest -> Maybe (ByteString, [(CI ByteString, ByteString)])

-- | An <a>X.509 certificate</a> chain supplied by the peer. It can be
--   assumed that the transport layer implementation already verified that
--   the peer owns the corresponding private key. The validation of the
--   certificate claims (including certificate chain checking) <i>must</i>
--   be performed by the <a>Authenticator</a>.
[requestCertificateChain] :: ConnectionRequest -> Maybe CertificateChain
[requestRemoteAddress] :: ConnectionRequest -> Maybe ByteString
instance GHC.Show.Show Network.MQTT.Authentication.ConnectionRequest


module Network.MQTT.Session
type Identifier = Int
data Session auth
Session :: !(Principal auth) -> !ClientIdentifier -> !Identifier -> !(MVar (RoutingTree (Identity QualityOfService))) -> !(MVar (IntMap Message)) -> !(MVar ServerQueue) -> !(MVar ()) -> Int -> Session auth
[sessionPrincipal] :: Session auth -> !(Principal auth)
[sessionClientIdentifier] :: Session auth -> !ClientIdentifier
[sessionIdentifier] :: Session auth -> !Identifier
[sessionSubscriptions] :: Session auth -> !(MVar (RoutingTree (Identity QualityOfService)))
[sessionIncompleteQos2] :: Session auth -> !(MVar (IntMap Message))
[sessionQueue] :: Session auth -> !(MVar ServerQueue)
[sessionQueuePending] :: Session auth -> !(MVar ())
[sessionQueueLimitQos0] :: Session auth -> Int
data ServerQueue
ServerQueue :: !(Seq Int) -> !(Seq Int) -> !(Seq Int) -> !(Seq Int) -> !(Seq (Int, [Maybe QualityOfService])) -> !(Seq Int) -> !(Seq Message) -> !(Seq Message) -> !(Seq Message) -> !(IntMap Message) -> !(IntMap Message) -> !(IntMap Message) -> ServerQueue
[queuePids] :: ServerQueue -> !(Seq Int)
[queueAcknowledged] :: ServerQueue -> !(Seq Int)
[queueReceived] :: ServerQueue -> !(Seq Int)
[queueCompleted] :: ServerQueue -> !(Seq Int)
[queueSubscribed] :: ServerQueue -> !(Seq (Int, [Maybe QualityOfService]))
[queueUnsubscribed] :: ServerQueue -> !(Seq Int)
[queueQos0] :: ServerQueue -> !(Seq Message)
[queueQos1] :: ServerQueue -> !(Seq Message)
[queueQos2] :: ServerQueue -> !(Seq Message)
[queueUnacknowledged] :: ServerQueue -> !(IntMap Message)
[queueUnreceived] :: ServerQueue -> !(IntMap Message)
[queueUncompleted] :: ServerQueue -> !(IntMap Message)
emptyServerQueue :: Int -> ServerQueue
notePending :: Session auth -> IO ()
enqueueMessage :: Session auth -> Message -> IO ()
enqueueMessages :: Foldable t => Session auth -> t Message -> IO ()
enqueuePublishAcknowledged :: Session auth -> PacketIdentifier -> IO ()
enqueuePublishReceived :: Session auth -> PacketIdentifier -> IO ()
enqueuePublishCompleted :: Session auth -> PacketIdentifier -> IO ()
enqueueSubscribeAcknowledged :: Session auth -> PacketIdentifier -> [Maybe QualityOfService] -> IO ()
enqueueUnsubscribeAcknowledged :: Session auth -> PacketIdentifier -> IO ()

-- | Blocks until messages are available and prefers non-qos0 messages over
--   qos0 messages.
dequeue :: Session auth -> IO (Seq ServerMessage)
dequeueQos0 :: ServerQueue -> (ServerQueue, Seq ServerMessage)
holdQos2Message :: Session auth -> PacketIdentifier -> Message -> IO ()
releaseQos2Message :: Session auth -> PacketIdentifier -> IO (Maybe Message)
dequeueNonQos0 :: ServerQueue -> (ServerQueue, Seq ServerMessage)
instance GHC.Classes.Eq (Network.MQTT.Session.Session auth)
instance GHC.Classes.Ord (Network.MQTT.Session.Session auth)


module Network.MQTT.Broker
data Broker auth
Broker :: auth -> MVar RetainedTree -> MVar (BrokerState auth) -> Broker auth
[brokerAuthenticator] :: Broker auth -> auth
[brokerRetainedMessages] :: Broker auth -> MVar RetainedTree
[brokerState] :: Broker auth -> MVar (BrokerState auth)
data BrokerState auth
BrokerState :: !Identifier -> !(RoutingTree IntSet) -> !(IntMap (Session auth)) -> !(Map (Principal auth) (Map ClientIdentifier Int)) -> BrokerState auth
[brokerMaxSessionIdentifier] :: BrokerState auth -> !Identifier
[brokerSubscriptions] :: BrokerState auth -> !(RoutingTree IntSet)
[brokerSessions] :: BrokerState auth -> !(IntMap (Session auth))
[brokerPrincipals] :: BrokerState auth -> !(Map (Principal auth) (Map ClientIdentifier Int))
new :: Authenticator auth => auth -> IO (Broker auth)
data SessionConfig
SessionConfig :: Int -> Int -> Int -> SessionConfig
[sessionConfigQueue0MaxSize] :: SessionConfig -> Int
[sessionConfigQueue1MaxSize] :: SessionConfig -> Int
[sessionConfigQueue2MaxSize] :: SessionConfig -> Int
defaultSessionConfig :: SessionConfig
withSession :: (Authenticator auth) => Broker auth -> ConnectionRequest -> IO () -> (AuthenticationException auth -> IO ()) -> (Session auth -> SessionPresent -> Principal auth -> IO ()) -> IO ()
getSession :: Authenticator auth => Principal auth -> ClientIdentifier -> BrokerState auth -> IO (BrokerState auth, (SessionPresent, Session auth))
closeSession :: Authenticator auth => Broker auth -> Session auth -> IO ()
publishDownstream :: Broker auth -> Message -> IO ()

-- | Publish a message on the broker regarding specific permissions of the
--   session.
--   
--   QUESTION: Where do qos 1 and 2 messages get acknowledged?
publishUpstream :: Authenticator auth => Broker auth -> Session auth -> Message -> IO ()
publishUpstream' :: Broker auth -> Message -> IO ()
subscribe :: Authenticator auth => Broker auth -> Session auth -> PacketIdentifier -> [(Filter, QualityOfService)] -> IO ()
unsubscribe :: Broker auth -> Session auth -> PacketIdentifier -> [Filter] -> IO ()


module Network.MQTT


module Network.Stack.Server
data TLS a
data WebSocket a
class (Typeable a) => ServerStack a where data Server a data ServerConfig a data ServerException a data ServerConnection a data ServerConnectionInfo a where {
    data family Server a;
    data family ServerConfig a;
    data family ServerException a;
    data family ServerConnection a;
    data family ServerConnectionInfo a;
}

-- | Creates a new server from a configuration and passes it to a handler
--   function.
--   
--   The server given to the handler function shall be bound and in
--   listening state. The handler function is usually a <a>forever</a> loop
--   that accepts and handles new connections.
--   
--   <pre>
--   withServer config $ \server-&gt;
--     forever $ withConnection handleConnection
--   </pre>
withServer :: ServerStack a => ServerConfig a -> (Server a -> IO b) -> IO b

-- | Waits for and accepts a new connection from a listening server and
--   passes it to a handler function.
--   
--   This operation is blocking until the lowest layer in the stack accepts
--   a new connection. The handlers of all other layers are executed within
--   an <a>Async</a> which is returned. This allows the main thread waiting
--   on the underlying socket to block just as long as necessary. Upper
--   layer protocol handshakes (TLS etc) will be executed in the new
--   thread.
--   
--   <pre>
--   withServer config $ \server-&gt; forever $
--     future &lt;- withConnection server handleConnection
--     putStrLn "The lowest layer accepted a new connection!"
--     async $ do
--         result &lt;- wait future
--         putStrLn "The connection handler returned:"
--         print result
--   </pre>
withConnection :: ServerStack a => Server a -> (ServerConnection a -> ServerConnectionInfo a -> IO b) -> IO (Async b)
class ServerStack a => StreamServerStack a where sendStream server bs = fromIntegral <$> sendStreamLazy server (fromStrict bs) sendStreamLazy server = foldM (\ sent bs -> sendStream server bs >>= \ sent' -> pure $! sent + fromIntegral sent') 0 . toChunks sendStreamBuilder server chunksize = sendStreamLazy server . toLazyByteStringWith (untrimmedStrategy chunksize chunksize) mempty receiveStream server i = toStrict <$> receiveStreamLazy server i receiveStreamLazy server i = fromStrict <$> receiveStream server i
sendStream :: StreamServerStack a => ServerConnection a -> ByteString -> IO Int
sendStreamLazy :: StreamServerStack a => ServerConnection a -> ByteString -> IO Int64
sendStreamBuilder :: StreamServerStack a => ServerConnection a -> Int -> Builder -> IO Int64
receiveStream :: StreamServerStack a => ServerConnection a -> Int -> IO ByteString
receiveStreamLazy :: StreamServerStack a => ServerConnection a -> Int -> IO ByteString

-- | This class is an abstraction for <a>ServerStack</a>s that support the
--   transmission and reception of finite messages.
class ServerStack a => MessageServerStack a where type ClientMessage a type ServerMessage a where {
    type family ClientMessage a;
    type family ServerMessage a;
}

-- | Send a message.
--   
--   <ul>
--   <li>Returns the encoded message size.</li>
--   </ul>
sendMessage :: MessageServerStack a => ServerConnection a -> ServerMessage a -> IO Int64

-- | Send several messages. This might lead to an improvement for very
--   short messages.
--   
--   <ul>
--   <li>Returns the summed size of all encoded messages.</li>
--   </ul>
sendMessages :: (MessageServerStack a, Foldable t) => ServerConnection a -> t (ServerMessage a) -> IO Int64

-- | Receive a message.
--   
--   <ul>
--   <li>The second parameter determines the maximum encoded message size
--   which must not be exceeded by the client or an exception will be
--   thrown. Implementations shall track the consumed bytes and shall throw
--   an exception as soon as the limit is exceeded even if the message is
--   not yet complete. This is important to prevent _denial of service_
--   attacks.</li>
--   </ul>
receiveMessage :: MessageServerStack a => ServerConnection a -> Int64 -> IO (ClientMessage a)

-- | Consumes incoming messages with a supplied consumer callback.
--   
--   <ul>
--   <li>The second parameter limits the size of a single encoded message
--   (see <a>receiveMessage</a>).</li>
--   </ul>
consumeMessages :: MessageServerStack a => ServerConnection a -> Int64 -> (ClientMessage a -> IO Bool) -> IO ()
instance GHC.Show.Show (System.Socket.Internal.Socket.SocketAddress f) => GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo (System.Socket.Internal.Socket.Socket f t p))
instance GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo a) => GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo (Network.Stack.Server.TLS a))
instance GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo a) => GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo (Network.Stack.Server.WebSocket a))
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable p, System.Socket.Internal.Socket.Family f, System.Socket.Internal.Socket.Protocol p) => Network.Stack.Server.StreamServerStack (System.Socket.Internal.Socket.Socket f System.Socket.Type.Stream.Stream p)
instance Network.Stack.Server.StreamServerStack a => Network.Stack.Server.StreamServerStack (Network.Stack.Server.TLS a)
instance Network.Stack.Server.StreamServerStack a => Network.Stack.Server.StreamServerStack (Network.Stack.Server.WebSocket a)
instance (System.Socket.Internal.Socket.Family f, System.Socket.Internal.Socket.Type t, System.Socket.Internal.Socket.Protocol p, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable p) => Network.Stack.Server.ServerStack (System.Socket.Internal.Socket.Socket f t p)
instance Network.Stack.Server.StreamServerStack a => Network.Stack.Server.ServerStack (Network.Stack.Server.TLS a)
instance Network.Stack.Server.StreamServerStack a => Network.Stack.Server.ServerStack (Network.Stack.Server.WebSocket a)


module Network.MQTT.Server
data MQTT transport
type RecentActivity = IORef Bool
class ServerStack a => MqttServerTransportStack a
getConnectionRequest :: MqttServerTransportStack a => ServerConnectionInfo a -> IO ConnectionRequest
handleConnection :: forall transport auth. (StreamServerStack transport, MqttServerTransportStack transport, Authenticator auth) => Broker auth -> ServerConfig (MQTT transport) -> ServerConnection (MQTT transport) -> ServerConnectionInfo (MQTT transport) -> IO ()
instance GHC.Show.Show (Network.Stack.Server.ServerException (Network.MQTT.Server.MQTT transport))
instance GHC.Classes.Ord (Network.Stack.Server.ServerException (Network.MQTT.Server.MQTT transport))
instance GHC.Classes.Eq (Network.Stack.Server.ServerException (Network.MQTT.Server.MQTT transport))
instance GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo transport) => GHC.Show.Show (Network.Stack.Server.ServerConnectionInfo (Network.MQTT.Server.MQTT transport))
instance Data.Typeable.Internal.Typeable transport => GHC.Exception.Exception (Network.Stack.Server.ServerException (Network.MQTT.Server.MQTT transport))
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable p, System.Socket.Internal.Socket.Family f, System.Socket.Internal.Socket.Protocol p, System.Socket.Internal.Socket.Type t, System.Socket.Internal.AddressInfo.HasNameInfo f) => Network.MQTT.Server.MqttServerTransportStack (System.Socket.Internal.Socket.Socket f t p)
instance (Network.Stack.Server.StreamServerStack a, Network.MQTT.Server.MqttServerTransportStack a) => Network.MQTT.Server.MqttServerTransportStack (Network.Stack.Server.WebSocket a)
instance (Network.Stack.Server.StreamServerStack a, Network.MQTT.Server.MqttServerTransportStack a) => Network.MQTT.Server.MqttServerTransportStack (Network.Stack.Server.TLS a)
instance Network.Stack.Server.StreamServerStack transport => Network.Stack.Server.ServerStack (Network.MQTT.Server.MQTT transport)
instance Network.Stack.Server.StreamServerStack transport => Network.Stack.Server.MessageServerStack (Network.MQTT.Server.MQTT transport)
