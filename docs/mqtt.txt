-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package mqtt
@version 0.1.0.0


module Network.MQTT.Topic

-- | According to the MQTT specification a topic
--   
--   <ul>
--   <li>may not be empty</li>
--   <li>may not contain <tt>+</tt>, <tt>#</tt> or <tt>\NUL</tt>
--   characters</li>
--   </ul>
data Topic
data TopicFilter
data TopicFilterLevel
topicLevels :: Topic -> NonEmpty TopicFilterLevel
topicFilterLevels :: TopicFilter -> NonEmpty TopicFilterLevel
parseTopic :: Parser Topic
parseTopicFilter :: Parser TopicFilter
parseTopicFilterLevel :: Parser TopicFilterLevel
multiLevelWildcard :: TopicFilterLevel
singleLevelWildcard :: TopicFilterLevel
instance GHC.Classes.Ord Network.MQTT.Topic.Topic
instance GHC.Classes.Eq Network.MQTT.Topic.Topic
instance GHC.Classes.Ord Network.MQTT.Topic.TopicFilter
instance GHC.Classes.Eq Network.MQTT.Topic.TopicFilter
instance GHC.Classes.Ord Network.MQTT.Topic.TopicFilterLevel
instance GHC.Classes.Eq Network.MQTT.Topic.TopicFilterLevel
instance GHC.Show.Show Network.MQTT.Topic.Topic
instance GHC.Show.Show Network.MQTT.Topic.TopicFilter
instance GHC.Show.Show Network.MQTT.Topic.TopicFilterLevel
instance Data.String.IsString Network.MQTT.Topic.Topic
instance Data.String.IsString Network.MQTT.Topic.TopicFilter
instance Data.String.IsString Network.MQTT.Topic.TopicFilterLevel


module Network.MQTT.RoutingTree

-- | The <a>RoutingTree</a> is a map-like data structure designed to hold
--   elements that can efficiently be queried according to the matching
--   rules specified by MQTT. The primary purpose is to manage client
--   subscriptions, but it can just as well be used to manage permissions
--   etc.
--   
--   The tree consists of nodes that may or may not contain values. The
--   edges are filter components. As some value types have the concept of a
--   null (i.e. an empty set) the <a>RoutingTreeValue</a> is a class
--   defining the data family <a>RoutingTreeNode</a>. This is a performance
--   and size optimization to avoid unnecessary boxing and case
--   distinction.
newtype RoutingTree a
RoutingTree :: (Map TopicFilterLevel (RoutingTreeNode a)) -> RoutingTree a
class RoutingTreeValue a where data RoutingTreeNode a where {
    data family RoutingTreeNode a;
}
nodeNull :: RoutingTreeValue a => a -> Bool
nodeTree :: RoutingTreeValue a => RoutingTreeNode a -> RoutingTree a
nodeValue :: RoutingTreeValue a => RoutingTreeNode a -> Maybe a
nodeFromTree :: RoutingTreeValue a => RoutingTree a -> RoutingTreeNode a
nodeFromTreeAndValue :: RoutingTreeValue a => RoutingTree a -> a -> RoutingTreeNode a
null :: RoutingTree a -> Bool
empty :: RoutingTree a
singleton :: RoutingTreeValue a => TopicFilter -> a -> RoutingTree a

-- | Match a <a>Topic</a> against a <a>RoutingTree</a>.
--   
--   The function returns true iff the tree contains at least one node that
--   matches the topic <i>and</i> contains a value (including nodes that
--   are indirectly matched by wildcard characters like <a>+</a> and
--   <tt>#</tt> as described in the MQTT specification).
matchTopic :: RoutingTreeValue a => Topic -> RoutingTree a -> Bool

-- | Match a <a>TopicFilter</a> against a <a>RoutingTree</a>.
--   
--   The function returns true iff the tree contains a path that is <i>less
--   or equally specific</i> than the filter and the terminal node contains
--   a value that is not <a>nodeNull</a>.
--   
--   <pre>
--   match (singleton "#") "a"     = True
--   match (singleton "#") "+"     = True
--   match (singleton "#") "a/+/b" = True
--   match (singleton "#") "a/+/#" = True
--   match (singleton "+") "a"     = True
--   match (singleton "+") "+"     = True
--   match (singleton "+") "+/a"   = False
--   match (singleton "+") "#"     = False
--   match (singleton "a") "a"     = True
--   match (singleton "a") "b"     = False
--   match (singleton "a") "+"     = False
--   match (singleton "a") "#"     = False
--   </pre>
matchTopicFilter :: RoutingTreeValue a => TopicFilter -> RoutingTree a -> Bool
lookupWith :: (RoutingTreeValue a) => (a -> a -> a) -> Topic -> RoutingTree a -> Maybe a
insert :: RoutingTreeValue a => TopicFilter -> a -> RoutingTree a -> RoutingTree a
insertWith :: RoutingTreeValue a => (a -> a -> a) -> TopicFilter -> a -> RoutingTree a -> RoutingTree a
map :: (RoutingTreeValue a, RoutingTreeValue b) => (a -> b) -> RoutingTree a -> RoutingTree b
adjust :: RoutingTreeValue a => (a -> a) -> TopicFilter -> RoutingTree a -> RoutingTree a
delete :: RoutingTreeValue a => TopicFilter -> RoutingTree a -> RoutingTree a
unionWith :: (RoutingTreeValue a) => (a -> a -> a) -> RoutingTree a -> RoutingTree a -> RoutingTree a
differenceWith :: RoutingTreeValue a => (a -> a -> a) -> RoutingTree a -> RoutingTree a -> RoutingTree a
instance (Network.MQTT.RoutingTree.RoutingTreeValue a, GHC.Base.Monoid a) => GHC.Base.Monoid (Network.MQTT.RoutingTree.RoutingTree a)
instance Network.MQTT.RoutingTree.RoutingTreeValue Data.IntSet.Base.IntSet
instance Network.MQTT.RoutingTree.RoutingTreeValue (Data.Functor.Identity.Identity a)
instance Network.MQTT.RoutingTree.RoutingTreeValue ()
instance Network.MQTT.RoutingTree.RoutingTreeValue GHC.Types.Bool


module Network.MQTT.Broker
type SessionKey = Int
type Message = ()
newtype Broker
Broker :: MVar BrokerState -> Broker
[unBroker] :: Broker -> MVar BrokerState
newtype Session
Session :: MVar SessionState -> Session
[unSession] :: Session -> MVar SessionState
data QosLevel
Qos0 :: QosLevel
Qos1 :: QosLevel
Qos2 :: QosLevel
data BrokerState
BrokerState :: !SessionKey -> !(RoutingTree IntSet) -> !(IntMap Session) -> BrokerState
[brokerMaxSessionKey] :: BrokerState -> !SessionKey
[brokerSubscriptions] :: BrokerState -> !(RoutingTree IntSet)
[brokerSessions] :: BrokerState -> !(IntMap Session)
data SessionState
SessionState :: !Broker -> !SessionKey -> !(MVar ()) -> !(RoutingTree (Identity QosLevel)) -> !(BoundedChan (Topic, Message)) -> !(BoundedChan (Topic, Message)) -> !(BoundedChan (Topic, Message)) -> SessionState
[sessionBroker] :: SessionState -> !Broker
[sessionKey] :: SessionState -> !SessionKey
[sessionTermination] :: SessionState -> !(MVar ())
[sessionSubscriptions] :: SessionState -> !(RoutingTree (Identity QosLevel))
[sessionQueue0] :: SessionState -> !(BoundedChan (Topic, Message))
[sessionQueue1] :: SessionState -> !(BoundedChan (Topic, Message))
[sessionQueue2] :: SessionState -> !(BoundedChan (Topic, Message))
newBroker :: IO Broker
data SessionConfig
SessionConfig :: Int -> Int -> Int -> SessionConfig
[sessionConfigQueue0MaxSize] :: SessionConfig -> Int
[sessionConfigQueue1MaxSize] :: SessionConfig -> Int
[sessionConfigQueue2MaxSize] :: SessionConfig -> Int
createSession :: Broker -> SessionConfig -> IO Session
closeSession :: Session -> IO ()
subscribeSession :: Session -> [(TopicFilter, QosLevel)] -> IO ()
unsubscribeSession :: Session -> [TopicFilter] -> IO ()
deliverSession :: Session -> Topic -> Message -> IO ()
publishBroker :: Broker -> Topic -> Message -> IO ()
instance GHC.Show.Show Network.MQTT.Broker.QosLevel
instance GHC.Classes.Ord Network.MQTT.Broker.QosLevel
instance GHC.Classes.Eq Network.MQTT.Broker.QosLevel


module Network.MQTT.Authentication

-- | An <a>Authenticator</a> is able to determine a <a>Principal</a>'s
--   identity from a <a>Request</a>.
class Exception (AuthenticationException a) => Authenticator a where data Principal a data AuthenticationException a where {
    data family Principal a;
    data family AuthenticationException a;
}

-- | Try to determine a <a>Principal</a>'s identity from connection
--   <a>Request</a>.
--   
--   The operation shall return <a>Nothing</a> in case the authentication
--   mechanism is working, but couldn't associate an identity. It shall
--   throw and <a>AuthenticationException</a> in case of other problems.
authenticate :: (Authenticator a, Request c) => a -> c -> IO (Maybe (Principal a))

-- | This class defines how the information gathered from a connection
--   request looks like. An <a>Authenticator</a> may use whatever
--   information it finds suitable to authenticate the <a>Principal</a>.
class Request r where requestSecure = const False requestUsername = const Nothing requestPassword = const Nothing requestHeaders = const [] requestCertificateChain = const Nothing

-- | Is this connection secure in terms of <a>Transport Layer Security</a>?
requestSecure :: Request r => r -> Bool

-- | The username supplied with the MQTT handshake.
requestUsername :: Request r => r -> Maybe Text

-- | The password supplied with the MQTT handshake.
requestPassword :: Request r => r -> Maybe ByteString

-- | The HTTP request headers in case the client connected via
--   <a>WebSocket</a>.
requestHeaders :: Request r => r -> [(CI ByteString, ByteString)]

-- | An <a>X.509 certificate</a> chain supplied by the peer. It can be
--   assumed that the transport layer implementation already verified that
--   the peer owns the corresponding private key. The validation of the
--   certificate claims (including certificate chain checking) <i>must</i>
--   be performed by the <a>Authenticator</a>.
requestCertificateChain :: Request r => r -> Maybe CertificateChain


module Network.MQTT.Authorization

-- | An <a>Authorizer</a> is able to determine a <a>Principal</a>'s
--   permissions.
class (Authenticator a, Exception (AuthorizationException a)) => Authorizer a where data AuthorizationException a getPublishPermissions = pure mempty getSubscribePermissions = pure mempty where {
    data family AuthorizationException a;
}

-- | Determine the set of <tt>Topic</tt>s a <a>Principal</a> is allowed to
--   publish on.
--   
--   Beware that this operation is called on each publication. The
--   implementation is advised to cache the result (i.e. in an
--   <tt>MVar</tt>) and update it from time to time.
getPublishPermissions :: Authorizer a => Principal a -> IO (RoutingTree ())

-- | Determine the set of <tt>Filter</tt>s a <a>Principal</a> is allowed to
--   subscribe. The <a>Principal</a> is implicitly allowed to subscribe all
--   filters that are more specific than those explicitly stated in the
--   <a>RoutingTree</a>.
--   
--   Beware that this operation is called on each subscription. The
--   implementation is advised to cache the result (i.e. in an
--   <tt>MVar</tt>) and update it from time to time.
--   
--   Also note that <tt>Filter</tt>s already subscribed by the client won't
--   be unsubscribed if they are no longer in the current permission set.
--   There is no way specified by MQTT to signal this to the client other
--   than terminating the session.
getSubscribePermissions :: Authorizer a => Principal a -> IO (RoutingTree ())


module Network.MQTT.ServerStack
data SocketServerStack
data TlsServerStack a
data WebSocketServerStack a
class ServerStack a where data Server a data ServerConfig a data ServerConnection a data ServerConnectionRequest a where {
    data family Server a;
    data family ServerConfig a;
    data family ServerConnection a;
    data family ServerConnectionRequest a;
}
new :: ServerStack a => ServerConfig a -> IO (Server a)
start :: ServerStack a => Server a -> IO ()
stop :: ServerStack a => Server a -> IO ()
accept :: ServerStack a => Server a -> IO (ServerConnection a)
send :: ServerStack a => ServerConnection a -> ByteString -> IO ()
receive :: ServerStack a => ServerConnection a -> IO ByteString
close :: ServerStack a => ServerConnection a -> IO ()
instance Network.MQTT.ServerStack.ServerStack Network.MQTT.ServerStack.SocketServerStack
instance Network.MQTT.ServerStack.ServerStack a => Network.MQTT.ServerStack.ServerStack (Network.MQTT.ServerStack.TlsServerStack a)
instance Network.MQTT.ServerStack.ServerStack a => Network.MQTT.ServerStack.ServerStack (Network.MQTT.ServerStack.WebSocketServerStack a)
instance Network.MQTT.Authentication.Request (Network.MQTT.ServerStack.ServerConnectionRequest Network.MQTT.ServerStack.SocketServerStack)
instance Network.MQTT.Authentication.Request (Network.MQTT.ServerStack.ServerConnectionRequest a) => Network.MQTT.Authentication.Request (Network.MQTT.ServerStack.ServerConnectionRequest (Network.MQTT.ServerStack.TlsServerStack a))
instance Network.MQTT.Authentication.Request (Network.MQTT.ServerStack.ServerConnectionRequest a) => Network.MQTT.Authentication.Request (Network.MQTT.ServerStack.ServerConnectionRequest (Network.MQTT.ServerStack.WebSocketServerStack a))


module Network.MQTT.Message
newtype ClientIdentifier
ClientIdentifier :: Text -> ClientIdentifier
type SessionPresent = Bool
type CleanSession = Bool
type Retain = Bool
type KeepAlive = Word16
type Username = Text
type Password = ByteString
type TopicFilter = Text
newtype Topic
Topic :: ByteString -> Topic
type Payload = ByteString
newtype PacketIdentifier
PacketIdentifier :: Int -> PacketIdentifier
data QoS
QoS0 :: QoS
QoS1 :: QoS
QoS2 :: QoS
data QualityOfService
AtLeastOnce :: QualityOfService
ExactlyOnce :: QualityOfService
data ConnectionRefusal
UnacceptableProtocolVersion :: ConnectionRefusal
IdentifierRejected :: ConnectionRefusal
ServerUnavailable :: ConnectionRefusal
BadUsernameOrPassword :: ConnectionRefusal
NotAuthorized :: ConnectionRefusal
data PublishQoS
PublishQoS0 :: PublishQoS
PublishQoS1 :: !Duplicate -> !PacketIdentifier -> PublishQoS
PublishQoS2 :: !PacketIdentifier -> PublishQoS
data Will
Will :: Text -> ByteString -> Maybe QualityOfService -> Bool -> Will
[willTopic] :: Will -> Text
[willMessage] :: Will -> ByteString
[willQoS] :: Will -> Maybe QualityOfService
[willRetain] :: Will -> Bool
data RawMessage
Connect :: !ClientIdentifier -> !CleanSession -> !KeepAlive -> !(Maybe Will) -> !(Maybe (Username, Maybe Password)) -> RawMessage
[connectClientIdentifier] :: RawMessage -> !ClientIdentifier
[connectCleanSession] :: RawMessage -> !CleanSession
[connectKeepAlive] :: RawMessage -> !KeepAlive
[connectWill] :: RawMessage -> !(Maybe Will)
[connectCredentials] :: RawMessage -> !(Maybe (Username, Maybe Password))
ConnectAcknowledgement :: (Either ConnectionRefusal SessionPresent) -> RawMessage
Publish :: !Bool -> !Bool -> !Topic -> !PublishQoS -> !ByteString -> RawMessage
[publishDuplicate] :: RawMessage -> !Bool
[publishRetain] :: RawMessage -> !Bool
[publishTopic] :: RawMessage -> !Topic
[publishQoS] :: RawMessage -> !PublishQoS
[publishBody] :: RawMessage -> !ByteString
PublishAcknowledgement :: PacketIdentifier -> RawMessage
PublishReceived :: PacketIdentifier -> RawMessage
PublishRelease :: PacketIdentifier -> RawMessage
PublishComplete :: PacketIdentifier -> RawMessage
Subscribe :: PacketIdentifier -> [(TopicFilter, QoS)] -> RawMessage
SubscribeAcknowledgement :: PacketIdentifier -> [Maybe QoS] -> RawMessage
Unsubscribe :: PacketIdentifier -> [TopicFilter] -> RawMessage
UnsubscribeAcknowledgement :: PacketIdentifier -> RawMessage
PingRequest :: RawMessage
PingResponse :: RawMessage
Disconnect :: RawMessage
bRawMessage :: RawMessage -> Builder
pRawMessage :: Get RawMessage
pRemainingLength :: Get Int
bRemainingLength :: Int -> Builder
pUtf8String :: Get Text
bUtf8String :: Text -> Builder
instance GHC.Show.Show Network.MQTT.Message.RawMessage
instance GHC.Classes.Eq Network.MQTT.Message.RawMessage
instance GHC.Show.Show Network.MQTT.Message.PublishQoS
instance GHC.Classes.Ord Network.MQTT.Message.PublishQoS
instance GHC.Classes.Eq Network.MQTT.Message.PublishQoS
instance GHC.Show.Show Network.MQTT.Message.Will
instance GHC.Classes.Eq Network.MQTT.Message.Will
instance GHC.Enum.Bounded Network.MQTT.Message.ConnectionRefusal
instance GHC.Enum.Enum Network.MQTT.Message.ConnectionRefusal
instance GHC.Show.Show Network.MQTT.Message.ConnectionRefusal
instance GHC.Classes.Ord Network.MQTT.Message.ConnectionRefusal
instance GHC.Classes.Eq Network.MQTT.Message.ConnectionRefusal
instance GHC.Show.Show Network.MQTT.Message.QoS
instance GHC.Classes.Ord Network.MQTT.Message.QoS
instance GHC.Classes.Eq Network.MQTT.Message.QoS
instance GHC.Enum.Enum Network.MQTT.Message.QualityOfService
instance GHC.Show.Show Network.MQTT.Message.QualityOfService
instance GHC.Classes.Ord Network.MQTT.Message.QualityOfService
instance GHC.Classes.Eq Network.MQTT.Message.QualityOfService
instance GHC.Show.Show Network.MQTT.Message.PacketIdentifier
instance GHC.Classes.Ord Network.MQTT.Message.PacketIdentifier
instance GHC.Classes.Eq Network.MQTT.Message.PacketIdentifier
instance Data.String.IsString Network.MQTT.Message.Topic
instance GHC.Show.Show Network.MQTT.Message.Topic
instance GHC.Classes.Ord Network.MQTT.Message.Topic
instance GHC.Classes.Eq Network.MQTT.Message.Topic
instance Data.String.IsString Network.MQTT.Message.ClientIdentifier
instance GHC.Show.Show Network.MQTT.Message.ClientIdentifier
instance GHC.Classes.Ord Network.MQTT.Message.ClientIdentifier
instance GHC.Classes.Eq Network.MQTT.Message.ClientIdentifier


module Network.MQTT
data Message
Message :: Topic -> QoS -> Bool -> Bool -> Payload -> Message
[topic] :: Message -> Topic
[qos] :: Message -> QoS
[retained] :: Message -> Bool
[duplicate] :: Message -> Bool
[payload] :: Message -> Payload
instance GHC.Show.Show Network.MQTT.Message
instance GHC.Classes.Ord Network.MQTT.Message
instance GHC.Classes.Eq Network.MQTT.Message

module Network.Transceiver
class Transceiver a where type Data a type Exception a isTransceiverException _ _ = True where {
    type family Data a;
    type family Exception a;
}
isTransceiverException :: Transceiver a => a -> Exception a -> Bool
class Closable a
close :: Closable a => a -> IO ()
class Closable a => Creatable a
create :: Creatable a => IO a
class (Transceiver a, Closable a) => Connection a where isConnectedException _ _ = False isNotConnectedException _ _ = False isConnectionAbortedException _ _ = False isConnectionRefusedException _ _ = False isConnectionTimeoutException _ _ = False isConnectionResetException _ _ = False
isConnectedException :: Connection a => a -> Exception a -> Bool
isNotConnectedException :: Connection a => a -> Exception a -> Bool
isConnectionAbortedException :: Connection a => a -> Exception a -> Bool
isConnectionRefusedException :: Connection a => a -> Exception a -> Bool
isConnectionTimeoutException :: Connection a => a -> Exception a -> Bool
isConnectionResetException :: Connection a => a -> Exception a -> Bool
class (Connection a, Eq (Data a), Monoid (Data a)) => StreamConnection a where sendChunks a = mapM__ (sendChunk a) receiveChunks a = singleton <$> receiveChunk a
sendChunk :: StreamConnection a => a -> Data a -> IO ()
sendChunks :: (StreamConnection a, Chunks b, Chunk b ~ Data a) => a -> b -> IO ()
receiveChunk :: StreamConnection a => a -> IO (Data a)
receiveChunks :: (StreamConnection a, Chunks b, Chunk b ~ Data a) => a -> IO b
class Addressable a where type Address a where {
    type family Address a;
}
class (Connection a, Addressable a) => Bindable a where isAddressNotAvailableException _ _ = False
bind :: Bindable a => a -> Address a -> IO ()
isAddressNotAvailableException :: Bindable a => a -> Exception a -> Bool
class (Connection a, Addressable a) => Connectable a
connect :: Connectable a => a -> Address a -> IO ()
class (Connection (AcceptedConnection a), Addressable (AcceptedConnection a)) => Acceptable a where type AcceptedConnection a where {
    type family AcceptedConnection a;
}
listen :: Acceptable a => a -> Int -> IO ()
accept :: Acceptable a => a -> IO (AcceptedConnection a, Address (AcceptedConnection a))
class (Connection a) => DatagramConnection a where type Datagram a where {
    type family Datagram a;
}
sendDatagram :: DatagramConnection a => a -> Datagram a -> IO ()
receiveDatagram :: DatagramConnection a => a -> IO (Datagram a)
class Chunks a where type Chunk a where {
    type family Chunk a;
}
mapM__ :: Chunks a => (Chunk a -> IO ()) -> a -> IO ()
singleton :: Chunks a => Chunk a -> a
newtype TlsStream
TlsStream :: Context -> TlsStream
data SecureStreamServer t
SecureStreamServer :: ServerParams -> t -> Address t -> SecureStreamServer t
[serverParams] :: SecureStreamServer t -> ServerParams
[transport] :: SecureStreamServer t -> t
[bindAddress] :: SecureStreamServer t -> Address t
data SecureStreamServerException t
TlsException :: TLSException -> SecureStreamServerException t
TlsTransportException :: (Exception t) -> SecureStreamServerException t
instance Network.Transceiver.Chunks Data.ByteString.Lazy.Internal.ByteString
instance Network.Transceiver.Chunks [a]
instance Network.Transceiver.Transceiver (System.Socket.Internal.Socket.Socket f t p)
instance Network.Transceiver.Closable (System.Socket.Internal.Socket.Socket f t p)
instance (System.Socket.Internal.Socket.Family f, System.Socket.Internal.Socket.Type t, System.Socket.Internal.Socket.Protocol p) => Network.Transceiver.Creatable (System.Socket.Internal.Socket.Socket f t p)
instance Network.Transceiver.Addressable (System.Socket.Internal.Socket.Socket f t p)
instance Network.Transceiver.Connection (System.Socket.Internal.Socket.Socket f t p)
instance Network.Transceiver.StreamConnection (System.Socket.Internal.Socket.Socket f System.Socket.Type.Stream.Stream p)
instance Network.Transceiver.Connectable (System.Socket.Internal.Socket.Socket System.Socket.Family.Inet6.Inet6 t p)
instance Network.Transceiver.Acceptable (System.Socket.Internal.Socket.Socket System.Socket.Family.Inet6.Inet6 t p)
instance Network.Transceiver.Transceiver Network.Transceiver.TlsStream
instance Network.Transceiver.Closable Network.Transceiver.TlsStream
instance Network.Transceiver.Addressable Network.Transceiver.TlsStream
instance Network.Transceiver.Connection Network.Transceiver.TlsStream
instance Network.Transceiver.StreamConnection Network.Transceiver.TlsStream
instance Network.Transceiver.Transceiver t => Network.Transceiver.Transceiver (Network.Transceiver.SecureStreamServer t)
instance (Network.Transceiver.Acceptable t, Network.Transceiver.Data (Network.Transceiver.AcceptedConnection t) ~ Data.ByteString.Internal.ByteString, Network.Transceiver.AcceptedConnection t ~ t, Network.Transceiver.StreamConnection t) => Network.Transceiver.Acceptable (Network.Transceiver.SecureStreamServer t)


module Network.MQTT.IO
bufferedOutput :: (StreamConnection s, Data s ~ ByteString) => s -> IO RawMessage -> IO (Maybe RawMessage) -> (ByteString -> IO ()) -> IO ()

module Control.Concurrent.Broadcast
data Broadcast a
data BroadcastListener a
newBroadcast :: IO (Broadcast a)
broadcast :: Broadcast a -> a -> IO ()
terminate :: Broadcast a -> IO ()
listen :: Broadcast a -> IO (BroadcastListener a)
accept :: BroadcastListener a -> IO a
instance GHC.Show.Show Control.Concurrent.Broadcast.BroadcastTerminatedException
instance GHC.Exception.Exception Control.Concurrent.Broadcast.BroadcastTerminatedException


module Network.MQTT.Client
data Client t
data ClientConfiguration t
ClientConfiguration :: URI -> Maybe Will -> KeepAlive -> String -> Word16 -> IO t -> ClientConfiguration t

-- | <pre>
--   mqtt://user:password@server.example:1234
--   </pre>
[clientURI] :: ClientConfiguration t -> URI
[clientWill] :: ClientConfiguration t -> Maybe Will
[clientKeepAlive] :: ClientConfiguration t -> KeepAlive
[clientIdentifierPrefix] :: ClientConfiguration t -> String
[clientMaxUnacknowlegedMessages] :: ClientConfiguration t -> Word16
[clientNewTransceiver] :: ClientConfiguration t -> IO t
data ClientEvent
Started :: ClientEvent
Connecting :: ClientEvent
Connected :: ClientEvent
Ping :: ClientEvent
Pong :: ClientEvent
Received :: Message -> ClientEvent
Disconnected :: ClientException -> ClientEvent
Stopped :: ClientEvent
listenEvents :: Client s -> IO (BroadcastListener ClientEvent)
acceptEvent :: BroadcastListener ClientEvent -> IO ClientEvent
data ClientException
ProtocolViolation :: String -> ClientException
ConnectionRefused :: ConnectionRefusal -> ClientException
ClientLostSession :: ClientException
ServerLostSession :: ClientException
ClientClosedConnection :: ClientException
ServerClosedConnection :: ClientException
newClient :: ClientConfiguration t -> IO (Client t)

-- | Starts the <a>Client</a> if it is not already running.
--   
--   <ul>
--   <li>The <a>Started</a> event will be added to the event stream.</li>
--   <li>The <a>Connecting</a> event will be added to the event
--   stream.</li>
--   <li>A new <tt>Connectable</tt> will be created.</li>
--   <li>A connection will be tried to establish (includes <tt>connect</tt>
--   as well as the MQTT handshake).</li>
--   <li>The <a>Connected</a> event will be added to the event stream.</li>
--   <li>Messages will be processed until a <a>Disconnect</a> occurs.</li>
--   </ul>
--   
--   At every step after the <a>Connecting</a> event, a <a>Disconnect</a>
--   may occur. The client will then try to reconnect automatically.
start :: (Connectable s, Address s ~ a, StreamConnection s, Closable s, Data s ~ ByteString) => Client s -> IO ()

-- | Stops the <a>Client</a> if it is not already stopped.
--   
--   <ul>
--   <li>A graceful DISCONNECT packet will be sent to the server and the
--   connection will be <tt>close</tt>d.</li>
--   <li>All internal client threads will be terminated.</li>
--   <li>The <a>Stopped</a> event will be added to the event stream.</li>
--   </ul>
stop :: Closable s => Client s -> IO ()
publish :: Client s -> Topic -> QoS -> Retain -> Payload -> IO ()
subscribe :: Client s -> [(TopicFilter, QoS)] -> IO [Maybe QoS]
unsubscribe :: Client s -> [TopicFilter] -> IO ()
instance GHC.Show.Show Network.MQTT.Client.ClientEvent
instance GHC.Classes.Ord Network.MQTT.Client.ClientEvent
instance GHC.Classes.Eq Network.MQTT.Client.ClientEvent
instance GHC.Show.Show Network.MQTT.Client.ClientException
instance GHC.Classes.Ord Network.MQTT.Client.ClientException
instance GHC.Classes.Eq Network.MQTT.Client.ClientException
instance GHC.Show.Show Network.MQTT.Client.ClientConfigurationException
instance GHC.Exception.Exception Network.MQTT.Client.ClientConfigurationException
instance GHC.Exception.Exception Network.MQTT.Client.ClientException
